"""
Cloud Function to process product quality alerts and create JIRA tickets.
Triggered automatically when messages arrive in Pub/Sub.
"""

import base64
import json
import logging
import os
import sys
from typing import Any, Dict

import functions_framework
from cloudevents.http import CloudEvent
from google.cloud import secretmanager
from jira import JIRA

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def access_secret_version(secret_id: str) -> str:
    """Access a secret from Secret Manager."""
    client = secretmanager.SecretManagerServiceClient()
    response = client.access_secret_version(request={"name": secret_id})
    return response.payload.data.decode("UTF-8")


def create_product_quality_ticket(alert: Dict[str, Any]) -> Dict[str, str]:
    """
    Creates a JIRA ticket for a product quality issue.
    
    Args:
        alert: Dictionary containing product quality alert data
    
    Returns:
        Dictionary with status and ticket information
    """
    try:
        # Extract alert details
        severity = alert.get('severity', 'MEDIUM')
        product_name = alert.get('product_name', 'Unknown Product')
        product_id = alert.get('product_id', '')
        category = alert.get('category', '')
        brand = alert.get('brand', '')
        actions = alert.get('recommended_actions', [])
        
        # Get metrics directly from alert (not nested)
        avg_sentiment = alert.get('avg_sentiment')
        negative_ratio = alert.get('negative_ratio')
        sentiment_change = alert.get('sentiment_change')
        review_count = alert.get('review_count')
        recent_revenue = alert.get('recent_revenue', 0) or 0
        revenue_change_pct = alert.get('revenue_change_pct', 0) or 0
        revenue_at_risk = alert.get('revenue_at_risk', 0) or 0
        
        # Map severity to JIRA priority
        priority_map = {
            'CRITICAL': 'Highest',
            'HIGH': 'High',
            'MEDIUM': 'Medium',
            'LOW': 'Low'
        }
        jira_priority = priority_map.get(severity, 'Medium')
        
        # Build JIRA summary
        summary = f"Product Quality Alert: {product_name} - {severity} Severity"
        
        # Build comprehensive JIRA description
        description = f"""
h2. üö® Product Quality Issue Detected

*Product:* {product_name} (ID: {product_id})
*Category:* {category}
*Brand:* {brand}
*Severity:* {severity}
*Alert Time:* {alert.get('alert_timestamp', '')}

h3. üìä Key Metrics (Last {alert.get('analysis_period_days', 7)} Days)

*Sentiment Analysis:*
‚Ä¢ Average Sentiment Score: {avg_sentiment if avg_sentiment is not None else 'N/A'}
‚Ä¢ Negative Review Ratio: {f'{negative_ratio:.1%}' if negative_ratio is not None else 'N/A'}
‚Ä¢ Sentiment Change: {f'{sentiment_change:.1%}' if sentiment_change is not None else 'N/A'}
‚Ä¢ Review Count: {review_count if review_count is not None else 'N/A'}

*Financial Impact:*
‚Ä¢ Recent Revenue: ${recent_revenue:,.2f}
‚Ä¢ Revenue Change: {revenue_change_pct:+.1f}%
‚Ä¢ *Revenue at Risk:* ${revenue_at_risk:,.2f}

h3. üéØ Recommended Actions

"""
        
        # Add recommended actions
        if actions:
            for i, action in enumerate(actions, 1):
                description += f"{i}. {action}\n"
        else:
            description += "‚Ä¢ Review recent customer feedback\n‚Ä¢ Investigate quality control processes\n‚Ä¢ Consider product improvements\n"
        
        description += f"""

h3. üìà Analysis Details

This alert was generated by the *BigQuery Analytics Agent* using:
‚Ä¢ Sentiment-revenue correlation model (R¬≤ = 79.64%)
‚Ä¢ Time-series analysis of customer reviews
‚Ä¢ Revenue trend analysis
‚Ä¢ Automated quality issue detection

*Source:* Cloud Function - Automated Alert Processing
*Data Period:* Last {alert.get('analysis_period_days', 7)} days

h3. üîó Related Data

‚Ä¢ Product ID: {product_id}
‚Ä¢ Category: {category}
‚Ä¢ Brand: {brand}
‚Ä¢ Price Point: ${alert.get('price', 'N/A')}

---
_This ticket was automatically created via Cloud Function to accelerate time-to-action on product quality issues._
"""
        
        # Load JIRA configuration
        JIRA_API_KEY = access_secret_version("projects/900228280944/secrets/JIRA_API_KEY/versions/latest")
        JIRA_PROJECT_ID = os.getenv("JIRA_PROJECT_ID")
        JIRA_ISSUE_TYPE = os.getenv("JIRA_ISSUE_TYPE", "Task")
        JIRA_SERVER = os.getenv("JIRA_SERVER")
        USER_EMAIL = os.getenv("USER_EMAIL")
        
        if not all([JIRA_API_KEY, JIRA_PROJECT_ID, JIRA_SERVER, USER_EMAIL]):
            raise ValueError("Missing required JIRA environment variables")
        
        # Connect to JIRA
        jira_options = {'server': JIRA_SERVER}
        jira = JIRA(options=jira_options, basic_auth=(USER_EMAIL, JIRA_API_KEY))
        
        # Create issue with priority
        issue_dict = {
            'project': {'key': JIRA_PROJECT_ID},
            'summary': summary,
            'description': description,
            'issuetype': {'name': JIRA_ISSUE_TYPE},
            'priority': {'name': jira_priority},
            'labels': ['product-quality', 'sentiment-analysis', 'automated-alert', 'cloud-function', severity.lower()]
        }
        
        new_issue = jira.create_issue(fields=issue_dict)
        
        ticket_key = new_issue.key
        ticket_url = f"{JIRA_SERVER}/browse/{ticket_key}"
        
        logger.info(f"‚úÖ JIRA ticket created: {ticket_key} for {product_name} (severity: {severity})")
        
        return {
            "status": "success",
            "ticket_key": ticket_key,
            "ticket_url": ticket_url,
            "product_name": product_name,
            "severity": severity
        }
        
    except Exception as e:
        error_msg = f"Error creating JIRA ticket: {e}"
        logger.error(error_msg, exc_info=True)
        return {
            "status": "error",
            "message": error_msg
        }


@functions_framework.cloud_event
def process_quality_alert(cloud_event: CloudEvent) -> None:
    """
    Cloud Function triggered by Pub/Sub messages.
    Automatically creates JIRA tickets for product quality alerts.
    
    Args:
        cloud_event: CloudEvent containing the Pub/Sub message
    """
    try:
        # Decode the Pub/Sub message
        pubsub_message = base64.b64decode(cloud_event.data["message"]["data"]).decode()
        
        message_id = cloud_event.data.get("message", {}).get("messageId", "unknown")
        logger.info(f"üì® Received alert from Pub/Sub (Message ID: {message_id})")
        
        # Parse the alert JSON
        alert = json.loads(pubsub_message)
        product_name = alert.get('product_name', 'Unknown')
        product_id = alert.get('product_id', 'N/A')
        severity = alert.get('severity', 'UNKNOWN')
        revenue_at_risk = alert.get('revenue_at_risk', 0)
        
        logger.info(f"üîç Processing: {product_name} (ID: {product_id}, Severity: {severity}, Revenue at Risk: ${revenue_at_risk:,.2f})")
        
        # Create JIRA ticket
        result = create_product_quality_ticket(alert)
        
        if result["status"] == "success":
            logger.info(f"‚úÖ SUCCESS: Created {result['ticket_key']} for {result['product_name']}")
            logger.info(f"   URL: {result['ticket_url']}")
            logger.info(f"   Product ID: {product_id}, Revenue at Risk: ${revenue_at_risk:,.2f}")
        else:
            error_message = result.get('message', 'Unknown error')
            logger.error(f"‚ùå FAILED to create JIRA ticket for {product_name} (ID: {product_id})")
            logger.error(f"   Error: {error_message}")
            logger.error(f"   Severity: {severity}, Revenue at Risk: ${revenue_at_risk:,.2f}")
            
            # Check if it's a JIRA availability issue
            if "Site temporarily unavailable" in error_message or "404" in error_message:
                logger.warning(f"‚ö†Ô∏è  JIRA service appears to be unavailable - message will be retried")
                raise Exception(f"JIRA service unavailable: {error_message}")
            else:
                # For other errors, log but don't retry to avoid infinite loops
                logger.error(f"‚ö†Ô∏è  Non-retryable error - message will be acknowledged")
            
    except json.JSONDecodeError as e:
        logger.error(f"‚ùå Failed to parse Pub/Sub message JSON: {e}", exc_info=True)
        logger.error(f"   Raw message: {pubsub_message[:500]}")
        # Don't retry malformed messages
        
    except Exception as e:
        error_str = str(e)
        logger.error(f"‚ùå Error processing Pub/Sub message: {error_str}", exc_info=True)
        
        # Retry for transient errors (JIRA availability, network issues)
        if any(keyword in error_str.lower() for keyword in ['unavailable', 'timeout', 'connection', '404', '503', '502']):
            logger.warning(f"üîÑ Transient error detected - message will be retried by Pub/Sub")
            raise  # Re-raise to trigger retry
        else:
            logger.error(f"‚ö†Ô∏è  Permanent error - message will be acknowledged to avoid retry loop")
