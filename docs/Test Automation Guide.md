# Test Automation Guide for `addNums.py`

## 1. Introduction

This document serves as a comprehensive guide for understanding and implementing automated tests for the `addNums.py` module. It outlines the testing strategy, provides detailed test cases, and offers an example test suite to ensure the reliability and correctness of the `add_two_numbers` function.

The goal of this guide is to enable developers to efficiently create, execute, and maintain robust tests, thereby contributing to the overall stability and quality of the codebase.

## 2. Module Overview: `addNums.py`

The `addNums.py` module contains a single primary function, `add_two_numbers`, designed to sum two numerical inputs.

### 2.1. `add_two_numbers(num1, num2, corrID=None)` Function

**Description:**
This function is intended to take two numbers (`num1`, `num2`) as input, which can be either integers or string representations of integers. It attempts to convert these inputs to integers before performing the summation. The function also incorporates a logging mechanism to track its execution flow and includes support for correlation IDs in its log messages.

**Key Features:**

*   **Input Type Handling:** Attempts to convert both `num1` and `num2` to integers using `int()`.
*   **Logging:** Utilizes the Python `logging` module to record informational messages at various stages of execution (function call, conversion attempt, successful addition).
*   **Correlation ID Support:** Allows for an optional `corrID` parameter to be passed, which, if provided, overrides the globally defined `correlation_ID`. This ID is prepended to all log messages generated by the function, aiding in traceability.
*   **Return Value:** Returns the sum of the two converted integer inputs.

**Current Behavior for Invalid Inputs:**
*(**Note to Reader:** While the function's docstring states it "gracefully handles cases where inputs cannot be converted to numbers," the current implementation of `add_two_numbers` does not include an explicit `try-except` block for `ValueError` during input conversion. Therefore, if `num1` or `num2` cannot be converted to an integer, the function will raise a `ValueError` and terminate.)*

## 3. Testing Strategy

The primary testing strategy for `addNums.py` focuses on **Unit Testing**. Unit tests will isolate the `add_two_numbers` function and verify its behavior under various conditions, including valid inputs, edge cases, and error conditions (as currently implemented).

**Key Areas of Focus:**

*   **Correctness of Summation:** Ensure the function returns the mathematically correct sum for valid numerical inputs.
*   **Input Type Conversion:** Verify that string-represented numbers are correctly converted and summed.
*   **Error Handling (Current):** Confirm that non-convertible inputs correctly raise a `ValueError`.
*   **Logging Output:** Validate that appropriate informational messages are logged and that correlation IDs are correctly formatted and included.

**Tools:**
The standard Python `unittest` framework is recommended for creating and executing these tests due to its built-in capabilities and widespread use. Alternatively, `pytest` could be used for a more concise syntax.

## 4. Test Cases

This section outlines specific test cases to cover the functionality of `add_two_numbers`.

### 4.1. Positive Test Cases

These cases verify the function's behavior with valid inputs.

*   **Test Case 4.1.1: Adding Two Integers**
    *   **Input:** `num1=5`, `num2=3`
    *   **Expected Output:** `8`
    *   **Expected Logging:** Info messages indicating function call, conversion attempt, and successful addition, all prefixed with the default or provided correlation ID.

*   **Test Case 4.1.2: Adding Two String-Integers**
    *   **Input:** `num1="10"`, `num2="20"`
    *   **Expected Output:** `30`
    *   **Expected Logging:** Info messages indicating function call, successful conversion of strings to integers, and successful addition, all prefixed with the correlation ID.

*   **Test Case 4.1.3: Adding Mixed Type Inputs (Integer and String-Integer)**
    *   **Input:** `num1=7`, `num2="8"`
    *   **Expected Output:** `15`
    *   **Expected Logging:** Similar to above, confirming mixed input handling.

*   **Test Case 4.1.4: Using an Explicit Correlation ID**
    *   **Input:** `num1=1`, `num2=1`, `corrID="test-corr-id"`
    *   **Expected Output:** `2`
    *   **Expected Logging:** All info messages should start with `"test-corr-id - "`.

### 4.2. Negative/Edge Test Cases

These cases verify the function's behavior with invalid or boundary inputs, focusing on the current `ValueError` behavior.

*   **Test Case 4.2.1: Non-Numeric String Input for `num1`**
    *   **Input:** `num1="abc"`, `num2=5`
    *   **Expected Behavior:** Raises `ValueError`.
    *   **Expected Logging:** Info message for function call, then termination due to `ValueError` before successful addition is logged.

*   **Test Case 4.2.2: Non-Numeric String Input for `num2`**
    *   **Input:** `num1=5`, `num2="xyz"`
    *   **Expected Behavior:** Raises `ValueError`.
    *   **Expected Logging:** Similar to above.

*   **Test Case 4.2.3: Non-Numeric Inputs (e.g., `None`, `list`)**
    *   **Input:** `num1=None`, `num2=10`
    *   **Expected Behavior:** Raises `TypeError` (from `int(None)`) or `ValueError` depending on the type. For `int(None)` it's `TypeError`. For `int([1])` it's `TypeError`. For `int(object())` it's `TypeError`.
    *   **Expected Logging:** Info message for function call, then termination.
    *   *(**Correction**: `int()` raises `TypeError` for `None`, lists, etc., and `ValueError` for non-convertible strings. Test for `TypeError` when applicable.)*

### 4.3. Logging Verification

These cases specifically check the logging output.

*   **Test Case 4.3.1: Verify Info Log Messages on Success**
    *   **Input:** `num1=10`, `num2=20`
    *   **Expected Logging:**
        *   `'{correlation_ID} - Function `add_two_numbers` called with num1=10, num2=20.'`
        *   `'{correlation_ID} - Attempting to convert inputs to integers.'`
        *   `'{correlation_ID} - Successfully added 10 and 20. Result: 30'`
    *   The `{correlation_ID}` placeholder should be replaced by the actual ID used.

*   **Test Case 4.3.2: Verify Correlation ID in Logs**
    *   **Input:** `num1=1`, `num2=2`, `corrID="my-specific-id"`
    *   **Expected Logging:** All log messages should start with `"my-specific-id - "`.

## 5. Setting up the Test Environment

To run the tests for `addNums.py`, ensure you have Python 3 installed. No external libraries beyond the standard library are required for `addNums.py` itself or for using `unittest`.

1.  **Save the Code:** Save the provided `addNums.py` file in your project directory.
2.  **Create Test File:** Create a new Python file (e.g., `test_addNums.py`) in the same directory.

## 6. Running Tests

Tests can be executed directly from the command line using the `unittest` module.

Navigate to the directory containing `addNums.py` and your test file, then run:

```bash
python -m unittest test_addNums.py
```

This command will discover and run all test methods defined within `test_addNums.py`.

## 7. Example Test Suite (`test_addNums.py`)

Below is an example test suite using the `unittest` framework, incorporating the test cases outlined above. This suite also demonstrates how to capture and assert on log messages using `unittest.mock.patch`.

```python
import unittest
import logging
from unittest.mock import patch
import sys
from io import StringIO

# Import the function to be tested
from addNums import add_two_numbers, correlation_ID as default_correlation_ID

class TestAddTwoNumbers(unittest.TestCase):

    def setUp(self):
        # Capture logging output for each test
        self.log_stream = StringIO()
        self.handler = logging.StreamHandler(self.log_stream)
        self.original_handlers = logging.root.handlers[:]
        
        # Clear existing handlers to prevent duplicate output to console during tests
        for handler in logging.root.handlers[:]:
            logging.root.removeHandler(handler)
        
        logging.root.addHandler(self.handler)
        logging.root.setLevel(logging.INFO)
        # Ensure the formatter is set for the new handler as per addNums.py's basicConfig
        self.handler.setFormatter(logging.Formatter('%(message)s'))


    def tearDown(self):
        # Clean up logging handlers after each test
        logging.root.removeHandler(self.handler)
        for handler in self.original_handlers:
            logging.root.addHandler(handler)
        logging.root.setLevel(logging.NOTSET) # Reset level
        self.log_stream.close()

    def get_logged_messages(self):
        return self.log_stream.getvalue().strip().split('\n')

    # --- Positive Test Cases ---

    def test_add_integers(self):
        result = add_two_numbers(5, 3)
        self.assertEqual(result, 8)
        logs = self.get_logged_messages()
        self.assertIn(f'{default_correlation_ID} - Function `add_two_numbers` called with num1=5, num2=3.', logs)
        self.assertIn(f'{default_correlation_ID} - Successfully added 5 and 3. Result: 8', logs)

    def test_add_string_integers(self):
        result = add_two_numbers("10", "20")
        self.assertEqual(result, 30)
        logs = self.get_logged_messages()
        self.assertIn(f'{default_correlation_ID} - Function `add_two_numbers` called with num1=10, num2=20.', logs)
        self.assertIn(f'{default_correlation_ID} - Successfully added 10 and 20. Result: 30', logs)

    def test_add_mixed_types(self):
        result = add_two_numbers(7, "8")
        self.assertEqual(result, 15)
        logs = self.get_logged_messages()
        self.assertIn(f'{default_correlation_ID} - Function `add_two_numbers` called with num1=7, num2=8.', logs)
        self.assertIn(f'{default_correlation_ID} - Successfully added 7 and 8. Result: 15', logs)

    def test_custom_correlation_id(self):
        custom_id = "test-corr-id-123"
        result = add_two_numbers(1, 1, corrID=custom_id)
        self.assertEqual(result, 2)
        logs = self.get_logged_messages()
        self.assertIn(f'{custom_id} - Function `add_two_numbers` called with num1=1, num2=1.', logs)
        self.assertIn(f'{custom_id} - Successfully added 1 and 1. Result: 2', logs)
        # Ensure default correlation ID is NOT in logs
        self.assertNotIn(f'{default_correlation_ID} - Function `add_two_numbers` called', logs)

    # --- Negative/Edge Test Cases ---

    def test_non_numeric_string_input(self):
        with self.assertRaises(ValueError):
            add_two_numbers("abc", 5)
        # Check logs up to the point of failure (function called, conversion attempted)
        logs = self.get_logged_messages()
        self.assertIn(f'{default_correlation_ID} - Function `add_two_numbers` called with num1=abc, num2=5.', logs)
        self.assertIn(f'{default_correlation_ID} - Attempting to convert inputs to integers.', logs)
        self.assertNotIn(f'{default_correlation_ID} - Successfully added', logs) # Should not log success

    def test_none_input(self):
        with self.assertRaises(TypeError): # int(None) raises TypeError
            add_two_numbers(None, 10)
        logs = self.get_logged_messages()
        self.assertIn(f'{default_correlation_ID} - Function `add_two_numbers` called with num1=None, num2=10.', logs)
        self.assertIn(f'{default_correlation_ID} - Attempting to convert inputs to integers.', logs)
        self.assertNotIn(f'{default_correlation_ID} - Successfully added', logs)

    def test_list_input(self):
        with self.assertRaises(TypeError): # int([1]) raises TypeError
            add_two_numbers([1], 10)
        logs = self.get_logged_messages()
        self.assertIn(f'{default_correlation_ID} - Function `add_two_numbers` called with num1=[1], num2=10.', logs)
        self.assertIn(f'{default_correlation_ID} - Attempting to convert inputs to integers.', logs)
        self.assertNotIn(f'{default_correlation_ID} - Successfully added', logs)


    # --- Logging Verification ---

    def test_logging_messages_content(self):
        add_two_numbers(1, 2)
        logs = self.get_logged_messages()
        expected_logs = [
            f'{default_correlation_ID} - Function `add_two_numbers` called with num1=1, num2=2.',
            f'{default_correlation_ID} - Attempting to convert inputs to integers.',
            f'{default_correlation_ID} - Successfully added 1 and 2. Result: 3'
        ]
        for expected_log in expected_logs:
            self.assertIn(expected_log, logs)

    def test_logging_correlation_id_override(self):
        override_id = "override-123"
        add_two_numbers(1, 2, corrID=override_id)
        logs = self.get_logged_messages()
        self.assertTrue(all(override_id in log for log in logs if 'Function `add_two_numbers` called' in log or 'Attempting to convert inputs' in log or 'Successfully added' in log))
        self.assertFalse(any(default_correlation_ID in log for log in logs)) # Ensure default ID is not used when override is present

if __name__ == '__main__':
    unittest.main()
